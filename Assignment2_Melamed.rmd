---
title: "Assignment 2 - Linear Model Basics"
author: "Dana Melamed"
date: "March 6, 2018"
output: html_document
---

Load required packages and set seed to pseudo-random, for reproducible results:
```{r}
library(ggplot2)
library(dplyr)


set.seed = 12321
```

####  Question 1
Q1: Develop a function that will generate, for a range of each of ‘magnitude of B1’, ‘sample size’ and ‘error’, a measure of the quality of the parameter estimate. (Hint, that measure of quality is the t-value – the estimate scaled by the standard error of the estimate).

The function "gen.mod", given with the assignment, will be embedded into the solution.
```{r}
gen.mod <- function(n = 100, b0 =2, b1 = 3, sd.err =1){
  # Function: generate predictors and responses for given linear model parameters
  # Args: linear model parameters n, b0, b1, sd.err
  # Returns: dataframe of predictors and corresponding responses
  predictor <- runif(n) - 0.5
  response <- b0 + b1 * predictor + rnorm(n, mean = 0, sd = sd.err)
  return(data.frame(response = response, predictor = predictor))
}
```




To solve this problem, I am going to modify the given script to accept lists *and* single values of n, b1, b0,and sd.err. Then I am going to extract the t-value. Later in the assignment, the p-value needs to be extracted. This function was modified later to also extract the p-values.
```{r}
MakeParameterMatrix <- function(n_list, b0_list, b1_list, sd.err_list, rep){
  # Can use expand.grid instead of all this!
  # get coefficient for each predictor
  df <- matrix(ncol = 6, nrow =  (length(n_list)*
                                    length(b0_list)*
                                    length(b1_list)*
                                    length(sd.err_list)*
                                    rep))
  df <- as.data.frame(df)
  names(df) <- c("n","b0","b1","sd.err","t.value","pvalue")
  
  row = 1
  for (m in 1:rep){
    for(i in 1:length(n_list)){
      for(j in 1:length(b1_list)){
        for(k in 1:length(b0_list)){
          for(l in 1:length(sd.err_list)){
            m1 <- lm(response ~ predictor , 
                     data = gen.mod(n_list[[i]], b1_list[[j]], b0_list[[k]], sd.err_list[[l]]))
            
            df$n[[row]] <- n_list[[i]]
            df$b1[[row]] <- b1_list[[j]]
            df$b0[[row]] <- b0_list[[k]]
            df$sd.err[[row]] <- sd.err_list[[l]]
            df$t.value[[row]] <- summary(m1)[[4]][[6]]
            df$p.value[[row]] <- summary(m1)$coefficients[,4][[2]]
            row = row + 1
          }
        }
      }
    }
  }
  return(df)
}
```


#### Question 2
Q2: Use that function to produce a data frame, with various combinations of each of the three variables as ‘factors’ and the quality of the estimate as the response.

I am going to set lists of n, b1, and sd.err, and run the function MakeParameterMatrix.
```{r}
# Set parameters
n <- seq(100,1000,300)
b0 <- 2
b1 <- seq(1,20,5)
sd.err <- seq(1,3)
rep <- 1000

# Make dataframe
testdf_1 <- MakeParameterMatrix(n,b0,b1,sd.err, rep)
# Show sample
head(testdf_1)

```


#### Question 3
Q3: Show the results visually.



```{r}
testdf_1$b1 <- as.character(testdf_1$b1)
p <- ggplot(data = testdf_1, aes(t.value, group = b1, colour = b1))
p + geom_density() +
  facet_wrap(~n, labeller = label_bquote(Sample~~Size~~ .(n)))
```

#### Question 4
Q4: Do the same thing as above, but use a single parameter estimate of B1 = 0 (e.g. no effect). (Set B0 = 0). Use a sample size of 100. Instead of using the ‘t’ value as your ‘quality’ estimate, have the function output the ‘p-value’


```{r}

n <- 100
b0 <- 0
b1 <- 1
sd.err <- seq(1,3)
rep <- 1000

testdf_2 <- MakeParameterMatrix(n, b0, b1, sd.err, rep)

testdf_2$b1 <- as.character(testdf_2$b1)
p <- ggplot(data = testdf_2, aes(p.value, group = b1, colour = b1))
p + geom_density()
```


Q4b : What proportion of p-values are <= 0.05?

To answer this question, I am first going to make a function that takes a list of p-values, a value of alpha, and computes the proportion of pvalues that are equal to or below that alpha.
```{r}
GetProportionPvalBelowAlpha <- function(p.values, alpha){
  tot_p <- as.numeric(length(p.values))
  alpha_p <- as.numeric(length(which(p.values <= alpha)))
  pval_prop <- alpha_p/tot_p
  return(pval_prop)
}
```

the pval prop <= 0.05 should be 0.05


Now I can apply the function to the pvalues made in Q4a.
```{r}
pval_prop <- GetProportionPvalBelowAlpha(testdf_2$p.value, 0.05)
print(paste("Proportion of p-values below 0.05: ",pval_prop))
```


Q4c: How does that change when the amount of error changes.

To explore this question, I run model the function I made for calculating proportion of pvalue below an alpha, but for several different values of sd.err. Then I plotted the different proportion of pvalues <= 0 for each sd.err.
```{r}
sd.err  <- seq(1,5) # make range of sd.err

testdf_3 <- MakeParameterMatrix(n, b0, b1, sd.err, rep) 

pval.summary <- as.data.frame(
  matrix(ncol = 2, nrow = length(sd.err))
)
colnames(pval.summary) <- c("sd.err","pval_prop")


for(i in 1:length(sd.err)){
  sd.err.subset <- testdf_3 %>%
    filter(sd.err == sd.err[[i]])
  pval.summary$sd.err[[i]] <- sd.err[[i]]
  pval.summary$pval_prop[[i]] <- GetProportionPvalBelowAlpha(sd.err.subset$p.value, 0.05)
}

print(pval.summary)
```

